<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Lecode-Java-数组-获取长度&amp;返回数组方式</title>
    <link href="undefined2019/10/24/Lecode-Java-%E6%95%B0%E7%BB%84-%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%96%B9%E5%BC%8F/"/>
    <url>2019/10/24/Lecode-Java-%E6%95%B0%E7%BB%84-%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ol><li>题目：两数之和</li></ol><p>Java求解：</p><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        int[] result = new int[2];        for(int i=0; i&lt;nums.length-1; i++){ // 获得数组长度            for(int j=i+1; j&lt;nums.length; j++){                if(nums[i] + nums[j] == target){                    result[0] = i;                    result[1] = j;                }            }        }        return result; // 返回值为数组    }}</code></pre><ol start="2"><li>总结<br>获得数组长度方式：<pre><code>nums.length</code></pre>返回值为数组方式：<pre><code>int[] result = new int[2];result[0] = i;result[1] = j;return result;</code></pre></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java开发包的种类  --开学复习系列</title>
    <link href="undefined2019/09/07/Java%E5%BC%80%E5%8F%91%E5%8C%85%E7%9A%84%E7%A7%8D%E7%B1%BB-%E5%BC%80%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    <url>2019/09/07/Java%E5%BC%80%E5%8F%91%E5%8C%85%E7%9A%84%E7%A7%8D%E7%B1%BB-%E5%BC%80%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>Java开发包根据用途的不同已经分为Java EE、 Java SE 和Java ME 3个，求职者列出名称并具体描述每个开发包的用途即可。</p><p>Java JDK的版本分类如下：<br>Java ME （Java Platform Micro Edition）:一种以广泛的消费产品为目的的高度优化的Java运行环境，包括寻呼机、移动电话、可视电话、数字机顶盒等。它是致力于消费产品和嵌入式设备的开发人员的最佳选择。<br>Java SE （Java Platform Standard Edition）:SUN 公司针对桌面开发以及低端商务计算解决方案而开发的版本。<br>Java EE （Java Platform Enterprise Edition）:一种利用Java平台来简化企业解决方案的开发、部署和管理相关的复杂问题的体系结构。Java EE的基础是Java SE，Java EE不仅巩固了标准版中的许多优点，同时还提供了对EJB、Servlet、JSP以及XML技术的全面支持。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型训练过程问题：ImportError: No module named nets</title>
    <link href="undefined2019/05/07/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%9AImportError-No-module-named-nets/"/>
    <url>2019/05/07/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%9AImportError-No-module-named-nets/</url>
    
    <content type="html"><![CDATA[<p><strong>解决方法</strong><br>在代码前加：</p><blockquote><p>`<br>import sys<br>sys.path.append(“D:/毕设/models-master/models-master/research/slim”)</p></blockquote><p>`</p><p>参考链接：<br><a href="https://github.com/tensorflow/models/issues/1842" target="_blank" rel="noopener">https://github.com/tensorflow/models/issues/1842</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模型训练过程问题：AttributeError: module &#39;tensorflow.python.keras&#39; has no attribute &#39;Model&#39;</title>
    <link href="undefined2019/05/06/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%9AAttributeError-module-tensorflow-python-keras-has-no-attribute-Model/"/>
    <url>2019/05/06/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%9AAttributeError-module-tensorflow-python-keras-has-no-attribute-Model/</url>
    
    <content type="html"><![CDATA[<p>tensorflow-gpu 1.4.0版本<br>执行object_detection/legacy/train.py过程中报错如下：<br><code>AttributeError: module &#39;tensorflow.python.keras&#39; has no attribute &#39;Model&#39;</code><br>(执行命令为：</p><p><code>python legacy/train.py --logtostderr --train_dir=training/ --pipeline_config_path=ssd_mobilenet_v1_pets.config</code><br>参考链接：<a href="https://tomoya92.github.io/2018/09/17/tensorflow-object-detection/" target="_blank" rel="noopener">https://tomoya92.github.io/2018/09/17/tensorflow-object-detection/</a><br>)</p><p><strong>解决方法：</strong><br>将tf.keras.Model改为tf.keras.models.Model<br>参考链接：<a href="https://stackoverflow.com/questions/51873651/attributeerror-module-tensorflow-python-keras-has-no-attribute-model" target="_blank" rel="noopener">https://stackoverflow.com/questions/51873651/attributeerror-module-tensorflow-python-keras-has-no-attribute-model</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>监控视频图像抓取（VideoCapture）</title>
    <link href="undefined2019/04/22/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E6%8A%93%E5%8F%96%EF%BC%88VideoCapture%EF%BC%89/"/>
    <url>2019/04/22/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E6%8A%93%E5%8F%96%EF%BC%88VideoCapture%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-包安装"><a href="#1-包安装" class="headerlink" title="1. 包安装"></a>1. 包安装</h1><p>所需包：VideoCapture、PIL（我用的是python3.6，好像PIL不支持，所以下载的是pillow）</p><p>VideoCapture下载链接：（在页面Ctrl+F搜索VideoCapture）<br><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#videocapture" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#videocapture</a></p><p>下载对应版本后，在文件放置目录下打开命令行（shift+鼠标右键–&gt;当前位置打开命令窗）：<br>（如我下载的是VideoCapture-0.9.5-cp36-cp36m-win_amd64.whl）<br>pip install VideoCapture-0.9.5-cp36-cp36m-win_amd64.whl</p><p>pillow安装:<br>pip install pillow<br>参考链接：<br><a href="https://blog.csdn.net/dcz1994/article/details/71642979#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/dcz1994/article/details/71642979#commentBox</a></p><p>运行时可能会遇到一个小问题，直接点到问题代码处用frombytes代替fromstring<br>参考链接：<br><a href="https://blog.csdn.net/u010025211/article/details/75646981" target="_blank" rel="noopener">https://blog.csdn.net/u010025211/article/details/75646981</a></p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><pre><code># 抓取频率，抓取一次SLEEP_TIME_LONG = 10# 初始化摄像头cam = Device(devnum=0, showVideoWindow=0)while True:    imagePath = &#39;vedio_images/&#39; + str(0) + &#39;.jpg&#39;    # 抓图    cam.saveSnapshot(imagePath, timestamp=3, boldfont=1, quality=75)    # 加载图像    image = cv2.imread(imagePath)    # 休眠一下，等待一分钟    time.sleep(SLEEP_TIME_LONG)</code></pre><p>参考链接：<br><a href="https://www.kancloud.cn/digest/python-notes/163820" target="_blank" rel="noopener">https://www.kancloud.cn/digest/python-notes/163820</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>摄像 VideoCapture Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信公众号前端开发（WeUI）+AJAX</title>
    <link href="undefined2019/04/21/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%88WeUI%EF%BC%89-AJAX/"/>
    <url>2019/04/21/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%88WeUI%EF%BC%89-AJAX/</url>
    
    <content type="html"><![CDATA[<h1 id="1-微信公众号前端"><a href="#1-微信公众号前端" class="headerlink" title="1. 微信公众号前端"></a>1. 微信公众号前端</h1><blockquote><p>在web页面中开发主要用到WeUI、viewport、rem</p><ol><li>WeUI<blockquote><p>使用链接为<br><a href="https://github.com/pengtikui/WeUI-Simple-Guide" target="_blank" rel="noopener">https://github.com/pengtikui/WeUI-Simple-Guide</a><br>很好用可快速搞定前端页面显示 </p></blockquote></li><li>viewport<blockquote><p>链接为<br><a href="http://www.runoob.com/css/css-rwd-viewport.html" target="_blank" rel="noopener">http://www.runoob.com/css/css-rwd-viewport.html</a><br><code>`</code></p></blockquote></li></ol></blockquote><p><meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=false"></p><pre><code>&gt;&gt; 一行代码即可使页面适应手机屏幕，具体介绍可参考链接，很好用&gt;&gt; &gt; 3. rem&gt;&gt; rem之后好像没怎么用，以后有更多了解再来补充&gt;&gt; &gt; 4. 微信JSSDK开发文档&gt;&gt; 这个不太懂具体作用，以后了解了再来补充(..›ᴗ‹..)&gt;&gt; &gt; # 2. AJAX&gt; &gt; 之前开发中也有用到，经常用到，在这里总结一下，主要为代码举例（两个select级联）：&gt; &gt; 1. html:</code></pre><!--第一级（数据库读值）--><select class="weui-select" id="tblist" name="tblist" onchange="getCRList()"><br>    <option>请选择</option><br>    &lt;c:forEach var=”value” items=”${tblist}”&gt;<br>    <option value="${value}"><br>    ${value}<br>    </option><br>    &lt;/c:forEach&gt;<br></select><!--第二级（根据第一级的选择动态改变select列表）--><p><select class="weui-select" id="crlist" name="crlist" onchange="getResult()"><br></select></p><pre><code>&gt;&gt; &gt; 2. js:</code></pre><p>function getCRList() {<br>    var $tblist = $(“#tblist”).val();</p><pre><code>$(&#39;#tblist&#39;).val($tblist); //让第一个下拉框保持显示选中的值  $(&#39;#crlist&#39;).html(&quot;&quot;); //把ci内容设为空  var $crValue = $(&#39;#crlist&#39;); $crValue.append(&#39;&lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;&#39;);  $.ajax({    url : &quot;&lt;%=request.getContextPath()%&gt;/showCRList&quot;,    type : &quot;GET&quot;,    dataType : &quot;json&quot;,      async: false,//default is true ,and if it is true,the flag in ajax cant return                //cant be false because in chinese it means &quot;异步&quot;    data: {        tblist : $tblist  //传给后台的值    },    success : function(data, textStatus, jqXHR) {    //data为从后台取回的值                if (data &amp;&amp; data.length &gt; 0) {              var html = [];              for (var i = 0; i &lt; data.length; i++) {                 html.push(&#39;&lt;option value=&quot;&#39;+data[i]+&#39;&quot;&gt;&#39;+data[i]+&#39;&lt;/option&gt;&#39;);              }              $crValue.append(html.join(&#39;&#39;));          }      }      });}</code></pre><pre><code>&gt;&gt; &gt; 3. Servlet</code></pre><p>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p><pre><code>response.setContentType(&quot;application/json&quot;);  //使用json格式response.setCharacterEncoding(&quot;UTF-8&quot;);request.setCharacterEncoding(&quot;UTF-8&quot;);tblist = (String) request.getParameter(&quot;tblist&quot;);  //不可以用getAttribute...rtn2 = crUtil.getCRList(tblist);PrintWriter writer = response.getWriter();  JSONArray array = JSONArray.fromObject(rtn2); writer.append(array.toString());</code></pre><p>}</p><pre><code>&gt;&gt; &gt; 4. CRUtil</code></pre><p>public List<string> getCRList(String tbname){</string></p><pre><code>List&lt;String&gt; rtn2 = new ArrayList&lt;String&gt;();String sql2=&quot;SELECT NAME FROM crinfo WHERE tbId = (SELECT id FROM tbinfo WHERE NAME = &#39;&quot; + tbname + &quot;&#39;)&quot;;        rtn2 = dbutil.getListInfo(sql2);return rtn2;</code></pre><p>}</p><pre><code>&gt; 5. DatabaseUtil</code></pre><p>/*</p><pre><code>* 获得列表信息*/</code></pre><p>public List<string> getListInfo(String sql){</string></p><pre><code>List&lt;String&gt; rsList = new ArrayList&lt;String&gt;();String result = null;Connection conn=null;String url=&quot;jdbc:mysql://localhost:3306/person_seat_detection&quot;;String user_=&quot;root&quot;;String psd=&quot;123456&quot;;try {    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    conn=DriverManager.getConnection(url,user_,psd);    PreparedStatement ps=            conn.prepareStatement(sql);    ResultSet rs=ps.executeQuery();    while(rs.next()){        rsList.add(rs.getString(1));    }} catch (Exception e) {    System.out.println(e.getMessage());}finally {    if (conn!=null) {        try {            conn.close();        } catch (Exception e2) {        }    }}return rsList;</code></pre><p>}</p><pre><code>&gt;&gt; &gt; 6. web.xml配置&gt;&gt;</code></pre><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;crServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.imooc.servlet.CRServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;crServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/showCRList&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;```                            </code></pre><blockquote><blockquote></blockquote></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>微信公众号 前端 ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕设微信公众号开发过程记录</title>
    <link href="undefined2019/04/15/%E6%AF%95%E8%AE%BE%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>2019/04/15/%E6%AF%95%E8%AE%BE%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://www.imooc.com/video/7225" target="_blank" rel="noopener">https://www.imooc.com/video/7225</a></p><ol><li>ngrok映射工具，将内网映射到公网上，这样就可以在公网访问本地网络服务<blockquote><p>用法：</p><blockquote><ol><li>ngrok 8080</li><li>ngrok -config ngrok.cfg -subdomain example 8080<br>(tunnel:运行客户端时，输入以上内容，意为将本地的8080端口链接到example.tunnel.mobi上–本地在毕设文件夹内)</li></ol></blockquote><p>效果： </p><blockquote><p><a href="http://localhost:8080/Test/index.jsp" target="_blank" rel="noopener">http://localhost:8080/Test/index.jsp</a> ==<br><a href="http://example.tunnel.mobi/Test/index.jsp" target="_blank" rel="noopener">http://example.tunnel.mobi/Test/index.jsp</a></p></blockquote></blockquote></li><li>编写过程<blockquote><p>新建项目 –&gt;<br>写WeixinServlet(微信服务器的入口) –&gt;<br>写doGet方法获取微信传来的信息(写ChectkUtil对传来的信息进行校验) –&gt;<br>配置web.xml文件(访问链接为wx.do) –&gt;<br>启动 Tomcat+ngrok 测试访问 –&gt;<br>配置微信公众号中的url和token(点击提交，转到CheckUtil进行校验，提交成功说明开发环境与微信后台已对接成功) –&gt;<br>启用开发模式(编辑模式失效) –&gt;<br>消息传入(接入是通过get,消息微信服务器通过post发送请求，并通过xml格式返回数据) –&gt;<br>写doPost(xml转成集合map)</p><p>……</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>微信公众号 毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉八大任务概述</title>
    <link href="undefined2019/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%85%AB%E5%A4%A7%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/"/>
    <url>2019/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%85%AB%E5%A4%A7%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<br><a href="https://m.pythontab.com/article/1405" target="_blank" rel="noopener">https://m.pythontab.com/article/1405</a></p></blockquote><blockquote><p>在此作简要整理</p></blockquote><blockquote><p>计算机视觉领域的八大任务：<br>图像分类、目标检测、图像语义分割、场景文字识别 —四大基本任务场景（如何帮助计算机从单个或者一系列的图片中提取分析和理解的关键信息）<br>图像生成、人体关键点检测、视频分类、度量学习等。</p></blockquote><blockquote><p>一、图像分类</p><blockquote><p>得益于深度学习的推动，图像分类的准确率大幅度提升。在经典的数据集ImageNet上，训练图像分类任务常用的模型，包括AlexNet、VGG、GoogLeNet、ResNet、Inception-v4、MobileNet、MobileNetV2、DPN(Dual Path Network)、SE-ResNeXt、ShuffleNet等<br>模型的结构和复杂程度都不一样，最终得到的准确率也有所区别。</p></blockquote></blockquote><blockquote><p>二、目标检测</p><blockquote><p>目标检测人物的目标是给定一张图像或是一个视频帧，让计算机找出其中所有目标的位置，并给出每个目标的具体类别。<br>在目标检测任务中，我们主要介绍如何基于PASCAL VOC、MS COCO数据训练通用物体检测模型，包括SSD模型、PyramidBox模型、R-CNN模型。</p><ul><li>“SSD模型，Single Shot MultiBox Detector，是一种单阶段的目标检测器。与两阶段的检测方法不同，单阶段目标检测并不进行区域推荐，而是直接从特征图回归出目标的边界框和分类概率。SSD 运用了这种单阶段检测的思想，并且对其进行改进：在不同尺度的特征图上检测对应尺度的目标，是目标检测领域较新且效果较好的检测算法之一，具有检测速度快且检测精度高的特点。”</li><li>“PyramidBox模型，百度自主研发的人脸检测模型，是一种语境辅助的单次人脸检测新方法，能够解决在不受控制的环境中检测小的、模糊的及部分遮挡的人脸时的问题，模型于18年3月份在WIDER Face数据集上取得第一名。”</li><li>“R-CNN系列模型，区域卷积神经网络(R-CNN)系列模型是典型的两阶段目标检测器，相较于传统提取区域的方法，R-CNN中RPN网络通过共享卷积层参数大幅提高提取区域的效率，并提出高质量的候选区域。Faster R-CNN和Mask R-CNN是R-CNN系列的典型模型。</li></ul></blockquote></blockquote><p>　　Faster R-CNN 区域生成网络(RPN)+Fast R-CNN的实现，将候选区域生成、特征提取、分类、位置精修统一到一个深度网络框架，大大提高运行速度。</p><p>　　Mask R-CNN在原有Faster R-CNN模型基础上添加分割分支，得到掩码结果，实现了掩码和类别预测关系的解藕，是经典的实例分割模型。”</p><blockquote><blockquote></blockquote><p>三、图像语义分割</p><blockquote><p>图像语义分割，顾名思义是将图像像素按照表达的语义含义的不同进行分组/切割。<br>分割任务主要分为实例分割和语义分割，实例分割是物体检测加上语义分割的综合体，上文介绍的Mask R-CNN是实例分割的经典网络结构之一。在语义分割任务中，我们主要介绍兼顾准确率和速度的ICNet，DeepLab中最新、执行效果最好的DeepLab v3+。</p></blockquote><p>四、场景文字识别</p><blockquote><p>图像语义分割，顾名思义是将图像像素按照表达的语义含义的不同进行分组/切割。<br>在场景文字识别任务中，我们介绍如何将基于CNN的图像特征提取和基于RNN的序列翻译技术结合，免除人工定义特征，避免字符分割，使用自动学习到的图像特征，完成字符识别。这里主要介绍CRNN-CTC模型和基于注意力机制的序列到序列模型。</p></blockquote><hr><p>一、图像生成</p><blockquote></blockquote><p>二、人体关键点检测</p><blockquote><p>人体关键点检测，通过人体关键节点的组合和追踪来识别人的运动和行为，对于描述人体姿态，预测人体行为至关重要，是诸多计算机视觉任务的基础，例如动作分类，异常行为检测，以及自动驾驶等等，也为游戏、视频等提供新的交互方式。</p></blockquote><p>三、视频分类</p><blockquote><p>视频分类方法主要包含基于卷积神经网络、基于循环神经网络、或将这两者结合的方法。</p></blockquote><p>四、度量学习</p><blockquote><p>度量学习也称作度量学习、相似度学习，通过学习对象之间的距离，度量学习能够用于分析对象时间的关联、比较关系，在实际问题中应用较为广泛，可应用于辅助分析、聚类分析，也广泛应用于图像检索、人脸识别等领域。</p></blockquote></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>win10 + VS2015 + CUDA8.0 + cudnn6.0 + tensorflow1.4.0</title>
    <link href="undefined2019/04/01/win10-VS2015-CUDA8-0-cudnn6-0-tensorflow1-4-0/"/>
    <url>2019/04/01/win10-VS2015-CUDA8-0-cudnn6-0-tensorflow1-4-0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>终于完成tensorflow-gpu的下载与成功使用，在此记录一下下载过程及下载过程中遇到的问题和解决方法</p><p>开始只安装了tensorflow 1.12.0，也不太清楚cpu、gpu等内容，然后运行github上下载的程序，报错如下：<br>报错：tensorflow.python.framework.errors_impl.InternalError: cudaGetDevice() failed.<br>        Status: CUDA driver version is insufficient for CUDA runtime version</p><p>上网查看后说是CUDA等的版本问题，然后一步一步下载…… </p><p>各种包、驱动等的版本号为：</p><blockquote><p>OS: win10<br>Anoconda Python 3.6.0<br>VS 2015<br>CUDA 8.0.61<br>cudnn-8.0-windows10-x64-v7.1-ga.zip（已改为cudnn-7.5-windows10-x64-v6.0.zip）<br>tensorflow 1.4.0</p></blockquote><ol><li>Anoconda Python 3.6.0<blockquote><p>之前电脑中已安装，官网下载即可</p></blockquote></li><li>VS 2015<blockquote><p>官网下载</p><p><img src="/2019/04/01/win10-VS2015-CUDA8-0-cudnn6-0-tensorflow1-4-0/安装包2.jpg" srcset="/img/loading.gif" alt></p><p>用该驱动打开 VS 2015的iso文件：<br><img src="/2019/04/01/win10-VS2015-CUDA8-0-cudnn6-0-tensorflow1-4-0/安装包3.jpg" srcset="/img/loading.gif" alt></p><p>参考链接：<br><a href="https://blog.csdn.net/guxiaonuan/article/details/73775519" target="_blank" rel="noopener">https://blog.csdn.net/guxiaonuan/article/details/73775519</a></p></blockquote></li></ol></blockquote><blockquote><ol start="3"><li>CUDA 8.0.61<blockquote><p>官网下载<br>注意事项：以管理员身份运行，精简安装（推荐）即可</p></blockquote></li><li>cudnn-8.0-windows10-x64-v7.1-ga.zip<blockquote><p>官网下载对应版本<br>需要注册并填问卷，下载后解压压缩包，将包内文件夹里面的内容分别拷贝到<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0里面的三个文件夹中去。<br>参考链接：<br><a href="https://blog.csdn.net/asd136912/article/details/79383161#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/asd136912/article/details/79383161#commentBox</a></p><p><img src="/2019/04/01/win10-VS2015-CUDA8-0-cudnn6-0-tensorflow1-4-0/安装包1.jpg" srcset="/img/loading.gif" alt></p><p>后面应用的时候遇到一个问题：（如没有遇到可忽略）</p><blockquote><p>ImportError: Could not find ‘cudnn64_6.dll’. TensorFlow requires that this DLL be installed in a directory that is named in your %PATH% environment variable. Note that installing cuDNN is a separate step from installing CUDA, and this DLL is often found in a different directory from the CUDA DLLs. You may install the necessary DLL by downloading cuDNN 6 from this URL: <a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a><br>解决方法：<br>如果你没有 cudnn64_6.dll, 可以使用如下方法：<br>在<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\bin文件夹中将 cudnn64_7.dll 或 cudnn64_8.dll 重命名为 cudnn64_6.dll</p><p>参考链接：<br><a href="https://github.com/tensorflow/tensorflow/issues/14946" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/issues/14946</a></p></blockquote><p>补充：（后续使用中）由于报错（如文章末尾描述），后修改为：（修改版本后替换原来的三个文件）</p><p><img src="/2019/04/01/win10-VS2015-CUDA8-0-cudnn6-0-tensorflow1-4-0/安装包4.jpg" srcset="/img/loading.gif" alt></p></blockquote></li><li>tensorflow 1.4.0<blockquote><p>如果之前装了cpu版本，也可以直接装gpu版本<br>命令为：pip install tensorflow-gpu==1.4.0</p><p>查看tensorflow版本<br><img src="/2019/04/01/win10-VS2015-CUDA8-0-cudnn6-0-tensorflow1-4-0/tfversion.jpg" srcset="/img/loading.gif" alt></p></blockquote></li></ol><p>其他参考链接：(参考了很多，有些忘记地址啦)</p><blockquote><p><a href="https://blog.csdn.net/asd136912/article/details/79383161#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/asd136912/article/details/79383161#commentBox</a><br><a href="https://blog.csdn.net/Kevin_HZH/article/details/81876527" target="_blank" rel="noopener">https://blog.csdn.net/Kevin_HZH/article/details/81876527</a></p></blockquote><p>实际运行中遇到问题：</p><blockquote><p>Loaded runtime CuDNN library: 7104 (compatibility version 7100) but source was compiled with 6021 (compatibility version 6000)<br>解决为：将cudnn版本由7.1改为了6.0<br>参考链接：<br><a href="https://github.com/keras-team/keras/issues/9567" target="_blank" rel="noopener">https://github.com/keras-team/keras/issues/9567</a></p></blockquote></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pycharm设置模板默认添加作者时间等信息</title>
    <link href="undefined2019/03/30/Pycharm%E8%AE%BE%E7%BD%AE%E6%A8%A1%E6%9D%BF%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E4%BD%9C%E8%80%85%E6%97%B6%E9%97%B4%E7%AD%89%E4%BF%A1%E6%81%AF/"/>
    <url>2019/03/30/Pycharm%E8%AE%BE%E7%BD%AE%E6%A8%A1%E6%9D%BF%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E4%BD%9C%E8%80%85%E6%97%B6%E9%97%B4%E7%AD%89%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://blog.csdn.net/qq_32040767/article/details/78981528#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/qq_32040767/article/details/78981528#commentBox</a><br>记录过程方便使用：</p><blockquote><p>File &gt; Settings &gt; Editor &gt; File and Code Templates<br>选择 Python Script<br>设置内容为： </p><blockquote><p>#encoding = utf-8</p><p>‘’’<br>Author : “Yuan Yunjing”<br>Date : “$DATE $TIME”<br>File : “$NAME .py”<br>IDE : “$PRODUCT_NAME”<br>‘’’</p></blockquote></blockquote></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git下载单个文件夹</title>
    <link href="undefined2019/03/16/git%E4%B8%8B%E8%BD%BD%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <url>2019/03/16/git%E4%B8%8B%E8%BD%BD%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近需要在github上下载一个项目，但是总是下载中断显示网络错误，可能是文件大，github下载困难（也不太清楚具体原因，有时间想做一个博客评论区，希望路过的大佬留下宝贵的意见、指导），于是想下载单个文件夹（因为项目需要，单个文件夹就可以了），找了好多方法，也有在Chrome中安装Otco Mate插件，据说是下载单个文件的，总之各种原因也没有成功，然后看到：<br><a href="https://github.com/Yangfan2016/Yangfan2016.github.io/blob/src/source/_posts/%E4%B8%8B%E8%BD%BD-Github-%E4%BB%93%E5%BA%93%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9.md" target="_blank" rel="noopener">https://github.com/Yangfan2016/Yangfan2016.github.io/blob/src/source/_posts/%E4%B8%8B%E8%BD%BD-Github-%E4%BB%93%E5%BA%93%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9.md</a><br>通过git命令成功下载，主要为：</p><ol><li>git init</li><li>git config core.sparseCheckout true</li><li>git remote add -f origin<br><a href="https://github.com/YuanYunjing/object_detector_app.git" target="_blank" rel="noopener">https://github.com/YuanYunjing/object_detector_app.git</a><br>最近总是报错：改成<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:YuanYunjing/raccoon_dataset.git可以执行</li><li>echo “object_detection/“ &gt;&gt; .git/info/sparse-checkout   # 引号中的内容为要下载的文件夹名称</li><li>git pull origin master<br>（2019/5/7一直报错<br>error: Sparse checkout leaves no entry on working directory<br>未解决）</li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕设python主要包知识整理备用</title>
    <link href="undefined2019/03/13/%E6%AF%95%E8%AE%BEpython%E4%B8%BB%E8%A6%81%E5%8C%85%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%A4%87%E7%94%A8/"/>
    <url>2019/03/13/%E6%AF%95%E8%AE%BEpython%E4%B8%BB%E8%A6%81%E5%8C%85%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%A4%87%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="argparse模块"><a href="#argparse模块" class="headerlink" title="argparse模块"></a>argparse模块</h1><blockquote><p>import argparse<br>parser = argparse.ArgumentParser()<br>parser.add_argument(‘-src’, ‘–source’, dest=’video_source’, type=int,<br>                        default=0, help=’Device index of the camera.’)<br>parser.add_argument(‘-wd’, ‘–width’, dest=’width’, type=int,<br>                        default=1280, help=’Width of the frames in the video stream.’)<br>parser.add_argument(‘-ht’, ‘–height’, dest=’height’, type=int,<br>                        default=720, help=’Height of the frames in the video stream.’)</p><p>print(args.width)<br>(参数依次为：dest - 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线<br>            type - 命令行参数应该被转换成的类型<br>            default - 不指定参数时的默认值<br>            help - 参数的帮助信息，当指定为 argparse.SUPPRESS 时表示不显示该参数的帮助信息.)<br>使用：e.g. 命令行输入python objection_detection_app.py –width 20<br>输出结果为20</p></blockquote></blockquote><blockquote><h1 id="数据库使用模块"><a href="#数据库使用模块" class="headerlink" title="数据库使用模块"></a>数据库使用模块</h1><p>2017 MySQLdb只支持Python2.<em> ，还不支持3.</em></p><blockquote><ol><li>MySQLdb<blockquote></blockquote><code>`</code> import MySQLdb</li></ol></blockquote></blockquote><p>db = MySQLdb.connect(“localhost”,”root”,’…’,’test’)</p><p>cursor = db.cursor()<br>name=”ali”<br>age = 10</p><h1 id="sql-“select-from-student-”"><a href="#sql-“select-from-student-”" class="headerlink" title="sql = “select * from student;”"></a>sql = “select * from student;”</h1><h1 id="sql-“insert-into-student-name-age-values-‘-s’-’-s’-”-name-age"><a href="#sql-“insert-into-student-name-age-values-‘-s’-’-s’-”-name-age" class="headerlink" title="sql = “insert into student(name,age) values(‘%s’,’%s’)”%(name, age)"></a>sql = “insert into student(name,age) values(‘%s’,’%s’)”%(name, age)</h1><p>sql = “delete from student where name=’%s’”%(name)<br>cursor.execute(sql)</p><h1 id="result-cursor-fetchall"><a href="#result-cursor-fetchall" class="headerlink" title="result = cursor.fetchall()"></a>result = cursor.fetchall()</h1><h1 id="print-type-result"><a href="#print-type-result" class="headerlink" title="print type(result)"></a>print type(result)</h1><p>db.commit()<br>db.close()</p><pre><code>&gt;&gt; 2. pymysql&gt;&gt;&gt; </code></pre><p>import pymysql</p><p>ms = pymysql.connect(host=’localhost’, user=’root’, passwd=’…’, database=’person_seat_detection’, charset=’utf8’)<br>cur = ms.cursor()</p><p>‘’’</p><h1 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h1><p>sql = “insert into schinfo values(1, ‘北华航天工业学院’, ‘河北省廊坊市’)”<br>cur.execute(sql)<br>ms.commit()<br>‘’’</p><h1 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h1><p>sql = “select * from schinfo”<br>count = cur.execute(sql)<br>for i in range(count):<br>    print(cur.fetchone())  # 结果为(1, ‘北华航天工业学院’, ‘河北省廊坊市’)</p><p>cur.close()<br>ms.close()</p><h1 id="count-cur-execute-“””SELECT-cid-sq-name-content-labels-score"><a href="#count-cur-execute-“””SELECT-cid-sq-name-content-labels-score" class="headerlink" title="count = cur.execute(“””SELECT cid, sq_name, content, labels, score"></a>count = cur.execute(“””SELECT cid, sq_name, content, labels, score</h1><h1 id="from-content-copy1-copy"><a href="#from-content-copy1-copy" class="headerlink" title="from content_copy1_copy"></a>from content_copy1_copy</h1><h1 id="where-labels-‘’”””"><a href="#where-labels-‘’”””" class="headerlink" title="where labels != ‘’”””)"></a>where labels != ‘’”””)</h1><h1 id="flag-0"><a href="#flag-0" class="headerlink" title="flag = 0"></a>flag = 0</h1><h1 id="for-i-in-range-count"><a href="#for-i-in-range-count" class="headerlink" title="for i in range(count):"></a>for i in range(count):</h1><h1 id="fc-cur-fetchone"><a href="#fc-cur-fetchone" class="headerlink" title="fc = cur.fetchone()"></a>fc = cur.fetchone()</h1><h1 id="cur-cid-ms-cursor"><a href="#cur-cid-ms-cursor" class="headerlink" title="cur_cid = ms.cursor()"></a>cur_cid = ms.cursor()</h1><h1 id="count-cid-cur-cid-execute-“select-cid-from-shequscore-copy1-copy-where-cid-s”-fc-0"><a href="#count-cid-cur-cid-execute-“select-cid-from-shequscore-copy1-copy-where-cid-s”-fc-0" class="headerlink" title="count_cid = cur_cid.execute(“select cid from shequscore_copy1_copy where cid = %s”, (fc[0]))"></a>count_cid = cur_cid.execute(“select cid from shequscore_copy1_copy where cid = %s”, (fc[0]))</h1><h1 id="if-count-cid-0"><a href="#if-count-cid-0" class="headerlink" title="if count_cid == 0:"></a>if count_cid == 0:</h1><h1 id="cur-inser-ms-cursor"><a href="#cur-inser-ms-cursor" class="headerlink" title="cur_inser = ms.cursor()"></a>cur_inser = ms.cursor()</h1><h1 id="cur-inser-execute-“insert-into-shequscore-copy1-copy-values-s-s-s-s-s-”"><a href="#cur-inser-execute-“insert-into-shequscore-copy1-copy-values-s-s-s-s-s-”" class="headerlink" title="cur_inser.execute(“insert into shequscore_copy1_copy values(%s, %s, %s, %s, %s)”,"></a>cur_inser.execute(“insert into shequscore_copy1_copy values(%s, %s, %s, %s, %s)”,</h1><h1 id="fc-0-fc-1-fc-2-fc-3-fc-4"><a href="#fc-0-fc-1-fc-2-fc-3-fc-4" class="headerlink" title="(fc[0], fc[1], fc[2], fc[3], fc[4]))"></a>(fc[0], fc[1], fc[2], fc[3], fc[4]))</h1><h1 id="flag-1"><a href="#flag-1" class="headerlink" title="flag += 1"></a>flag += 1</h1><h1 id="ms-commit"><a href="#ms-commit" class="headerlink" title="ms.commit()"></a>ms.commit()</h1><p><code>`</code></p><blockquote><blockquote></blockquote></blockquote><blockquote><h1 id="Python3多线程"><a href="#Python3多线程" class="headerlink" title="Python3多线程"></a>Python3多线程</h1><blockquote><p>线程可以分为:</p><ul><li>内核线程：由操作系统内核创建和撤销。</li><li>用户线程：不需要内核支持而在用户程序中实现的线程<br>Python3线程中常用的两个模块为：<br>_thread<br>threading(推荐使用)</li></ul><p>threading模块除了包含_thread模块中的所有方法外，还提供的其他方法：</p><ul><li>threading.currentThread():返回当前的线程变量</li><li>threading.enumerate():返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程</li><li>threading.activeCount():返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li><li>run():用以表示线程活动的方法。</li><li>start():启动线程活动。</li><li>join([time]):等待至线程中止。这阻塞调用线程直至线程的join()方法被调用中止-正常退出或抛出未处理的异常-或者是可选的超时发生。</li><li>isAlive():返回线程是否活动的。</li><li>getName():返回线程名。</li><li>setName():设置线程名。</li></ul><p>参考链接：<a href="http://www.runoob.com/python3/python3-multithreading.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-multithreading.html</a><br><a href="http://python.jobbole.com/81546/" target="_blank" rel="noopener">http://python.jobbole.com/81546/</a></p></blockquote></blockquote><blockquote><blockquote><ul><li>创建线程的方法之一：</li></ul><blockquote><p><code>import threading, time, randomcount = 0lock = threading.Lock()def doAdd():    &#39;&#39;&#39;@summary: 将全局变量count 逐一的增加10000。    &#39;&#39;&#39;    global count, lock    lock.acquire()    for i in xrange(10000):        count = count + 1    lock.release()for i in range(5):    threading.Thread(target = doAdd, args = (), name = &#39;thread-&#39; + str(i)).start()time.sleep(2)    # 确保线程都执行完毕print count</code><br><code>for i in range(1):        t = Thread(target=worker, args=(input_q, output_q))  # 线程开始执行worker方法，方法参数值为input_q, output_q        t.daemon = True  # 被 flag 为 daemon 的线程需要长期在后台执行（比如发送心跳包、检查未读消息等），并且不需和用户直接交互，和守护进程类似。        t.start()</code><br>解释：def <strong>init</strong>(self, group=None, target=None, name=None, args=(), kwargs={})</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><ul><li>参数group是预留的，用于将来扩展；</li><li>参数target是一个可调用对象（也称为活动[activity]），在线程启动后执行；</li><li>参数name是线程的名字。默认值为“Thread-N“，N是一个数字。</li><li>参数args和kwargs分别表示调用target时的参数列表和关键字参数。</li></ul></blockquote></blockquote><h1 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h1><blockquote><ul><li></li><li></li><li></li><li></li><li></li><li></li></ul></blockquote><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><blockquote><p>os.path.join() 用于路径拼接文件路径</p></blockquote></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda创建新的虚拟环境</title>
    <link href="undefined2019/03/12/Anaconda%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <url>2019/03/12/Anaconda%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><ol><li><p>用conda创建名为mytensorflow的新环境</p><blockquote><p>查看电脑的conda环境和版本</p><blockquote><p>conda info –envs<br>base是安装anaconda后默认创建的环境<br>conda –version<br>创建名字为mytensorflow python版本为3.6的新环境<br>conda create –name mytensorflow python=3.6<br>创建环境后用命令conda info –envs查看，星号代表正在运行的环境</p></blockquote></blockquote></li><li><p>激活刚刚创建的新环境</p><blockquote><p>activate mytensorflow<br>用命令conda info –envs查看，星号代表正在运行的环境</p></blockquote></li></ol><blockquote><p>…环境激活</p></blockquote><ol start="3"><li>在新环境中安装tensorflow<blockquote><p>查看Anaconda repository中我们可利用的版本</p><blockquote><p>conda search tensorflow<br>安装tensorflow<br>conda install tensorflow<br>……</p></blockquote></blockquote></li></ol><p>知识内容主要来源：<a href="https://zhuanlan.zhihu.com/p/37050300" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37050300</a><br>（起初是用于解决tensorflow异常终止问题，如该链接中楼主所整理）<br>知识搬运、整理(ﾉ∀｀)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Anaconda 知识搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git上传文件</title>
    <link href="undefined2019/03/08/git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <url>2019/03/08/git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章：<br>[1]git上传<br><a href="https://blog.csdn.net/chenyufeng1991/article/details/48930471" target="_blank" rel="noopener">https://blog.csdn.net/chenyufeng1991/article/details/48930471</a><br>[2]git上传两种方法<br><a href="https://blog.csdn.net/Lucky_LXG/article/details/77849212#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/Lucky_LXG/article/details/77849212#commentBox</a><br>[3]git-处理-github-不允许上传超过-100mb-文件的问题<br><a href="http://www.liuxiao.org/2017/02/git-%E5%A4%84%E7%90%86-github-%E4%B8%8D%E5%85%81%E8%AE%B8%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87-100mb-%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">http://www.liuxiao.org/2017/02/git-%E5%A4%84%E7%90%86-github-%E4%B8%8D%E5%85%81%E8%AE%B8%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87-100mb-%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</a></p><p>很长一段时间没有用git了，前几天使用git上传文件，又重新查找了一下git的使用方式，整理在这里</p><ol><li>git init<br>在本地建立git仓库（会在文件夹下建立.git隐藏文件）</li><li>git add .<br>将当前文件夹下的所有文件加载到本地暂存区</li><li>git commit -m “init commit”<br>提交到本地历史区<br><img src="/2019/03/08/git上传文件/1.png" srcset="/img/loading.gif" alt></li><li>git remote add origin <a href="https://github.com/YuanYunjing/shequkaifa0.0.git" target="_blank" rel="noopener">https://github.com/YuanYunjing/shequkaifa0.0.git</a><br>建立一个origin的远程仓库关联得到XX url</li><li>git push -u origin master<br>向git提交（在使用中报错![rejected]，后来发现是有一个超过100M的文件，删除文件后，可以成功执行了）<br><img src="/2019/03/08/git上传文件/2-1.png" srcset="/img/loading.gif" alt><br>（6. find ./ -size +100M  如何找到大于100M的文件）</li></ol></blockquote><hr><blockquote><ol start="5"><li>git pull –rebase origin master<br>若新建远程仓库的时候自动创建了README文件会报错，需先将github上的该文件拉下来，防止冲突<br><img src="/2019/03/08/git上传文件/2-2.png" srcset="/img/loading.gif" alt></li><li>git push -u origin master<br><img src="/2019/03/08/git上传文件/3-1.jpg" srcset="/img/loading.gif" alt></li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git学习笔记</title>
    <link href="undefined2019/03/04/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2019/03/04/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>更新：<br>hexo g -d 更新文件并发布到git上<br>hexo g 更新文件<br>hexo s 开启hexo本地服务器</p><p>(之前学习git记录的学习笔记‎2018‎年‎8‎月‎3‎日)</p><p>小结<br>现在总结一下今天学的两点内容：</p><p>初始化一个Git仓库，使用git init命令。</p><p>添加文件到Git仓库，分两步：</p><p>使用命令git add <file>，注意，可反复多次使用，添加多个文件；<br>使用命令git commit -m <message>，完成。</message></file></p><hr><p>小结<br>要随时掌握工作区的状态，使用git status命令。</p><p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p><hr><p>现在总结一下：</p><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p><hr><p>小结<br>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。</p><hr><p>小结<br>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</file></p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><hr><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>小结<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><hr><p>小结</p><h2 id="“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机"><a href="#“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机" class="headerlink" title="“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机"></a>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</h2><p>小结<br>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><h2 id="分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！"><a href="#分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！" class="headerlink" title="分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！"></a>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</h2><p>小结<br>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</p><h2 id="Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。"><a href="#Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。" class="headerlink" title="Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。"></a>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</h2><p>小结<br>Git鼓励大量使用分支：</p><p>查看分支：git branch</p><p>创建分支：git branch <name></name></p><p>切换分支：git checkout <name></name></p><p>创建+切换分支：git checkout -b <name></name></p><p>合并某分支到当前分支：git merge <name></name></p><p>删除分支：git branch -d <name></name></p><hr><p>小结<br>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用git log –graph命令可以看到分支合并图。 git log –graph –pretty=oneline –abbrev-commit</p><hr><p>小结<br>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><hr><p>小结<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p><hr><p>小结<br>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p><hr><p>因此，多人协作的工作模式通常是这样：</p><p>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></p><p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p>小结<br>查看远程库信息，使用git remote -v；</p><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p><hr><p>小结<br>rebase操作可以把本地未push的分叉提交历史整理成直线；</p><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><hr><p>小结<br>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</tagname></p><p>命令git tag -a <tagname> -m “blablabla…”可以指定标签信息；</tagname></p><p>命令git tag可以查看所有标签。</p><hr><p>小结<br>命令git push origin <tagname>可以推送一个本地标签；</tagname></p><p>命令git push origin –tags可以推送全部未推送过的本地标签；</p><p>命令git tag -d <tagname>可以删除一个本地标签；</tagname></p><p>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础复习（杂记，待更新）</title>
    <link href="undefined2019/02/19/JAVA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <url>2019/02/19/JAVA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><blockquote><h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><blockquote><ul><li>封装 给对象提供了隐藏内部特性和行为的能力<br>封装的一些好处：<blockquote><p>通过隐藏对象的属性来保护对象内部的状态<br>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展<br>禁止对象之间的不良交互提高模块化</p></blockquote></li><li>继承 <blockquote><p>继承给对象提供了从基类获取字段和方法的能力<br>提高了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性</p></blockquote></li><li>多态 <blockquote><p>多态存在的必要条件：<br>继承、重写、父类引用指向子类对象<br>多态的实现方式：<br>重写、接口、抽象类和抽象方法<br>多态的好处：<br>可以使程序有良好的扩展，并可以对所有类的对象进行通用处理</p></blockquote></li></ul></blockquote><h2 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final, finally, finalize"></a>final, finally, finalize</h2><blockquote><ul><li>final修饰符（关键字）<blockquote><p>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。（因此一个类不能既被声明为abstract的，有被声明为final的）。<br>将变量或方法声明为final，可以保证他们在使用中不被改变。（被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。）<br>被声明为final的方法也同样只能使用，不能重载（？）</p></blockquote></li><li>finally<blockquote><p>在异常处理时提供finally块来执行任何清除操作。如果抛出一个异常，那么相匹配的catch子句就会执行，然后控制就会进入finally块（如果有的话）。</p></blockquote></li><li>finalize 方法名<blockquote><p>Java技术允许finalize()在垃圾收集器讲对象从内存清理出去之前做必要的垃圾清理工作。这个方法是由垃圾处理器在确定这个对象没有被引用是对这个对象调用的。实在Object类中定义的，因此所有的类都继承了他。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。<br>finalize()方法是在垃圾收集器删除对象之前对这个对象调用的（不理解？）</p></blockquote></li></ul></blockquote><h2 id="int和integer有什么区别"><a href="#int和integer有什么区别" class="headerlink" title="int和integer有什么区别"></a>int和integer有什么区别</h2><blockquote><p>int是基本数据类型<br>Integer是其包装类，（是一个类）<br>为什么要提供包装类呢？</p><blockquote><p>一是为了在各种类型间转化，如int转化为String<br>‘’’<br>int a = 0;<br>String result = Integer.toString(a);<br>‘’’</p><p>二是泛型</p></blockquote></blockquote><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><blockquote><ul><li>override（重写）<br>方法名、参数、返回值相同<br>子类方法不能缩小父类方法的访问权限<br>子类方法不能抛出比父类方法更多的异常（但子类方法可以不抛出异常）<br>存在于父类和子类之间<br>方法被定义为final不能被重写</li><li>overload（重载）<br>参数类型、个数、顺序至少有一个不相同<br>不能重载只有返回值不同的方法名<br>存在于父类和子类、同类中（？）<br><img src="/2019/02/19/JAVA基础复习/16342c734014a933.png" srcset="/img/loading.gif" alt></li></ul></blockquote><h2 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h2><blockquote><p>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的<br>另外，实现接口的一定要实现接口里所有的方法，而实现抽象类可以有选择的<strong>重写</strong>需要用到的方法<br>一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现<br>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</p></blockquote><h2 id="反射的用途及实现"><a href="#反射的用途及实现" class="headerlink" title="反射的用途及实现"></a>反射的用途及实现</h2><blockquote><p>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的作用就是框架。<br>Java反射的主要功能：</p><ul><li>确定一个对象的类</li><li>取出类的modifiers、数据成员、方法、构造器和超类</li><li>找出某个接口里定义的常量和方法说明</li><li>创建一个类实例，这个实例在运行时才有名字（运行时才生成的对象）</li><li>取得和设定对象数据成员的值，如果数据成员名是运行时刻确定的也能做到</li><li>在运行时刻调用动态对象的方法</li><li>创建数组，数组大小和类型在运行时刻才确定，也能更改数组成员的值</li><li>反射的应用很多，很多框架都有用到</li></ul></blockquote></blockquote><p>spring 的 ioc/di 也是反射….<br>javaBean和jsp之间调用也是反射….<br>struts的 FormBean 和页面之间…也是通过反射调用….<br>JDBC 的 classForName()也是反射…..<br>hibernate的 find(Class clazz) 也是反射….<br>“<br>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣。怎么使用使你的系统达到最优就看你系统架构和综合使用问题啦，这里就不多说了。”</p><blockquote><h2 id="自定义注解的场景及实现"><a href="#自定义注解的场景及实现" class="headerlink" title="自定义注解的场景及实现"></a>自定义注解的场景及实现</h2><blockquote><p>待理解！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p></blockquote><h2 id="HTTP请求的GET和POST方式的区别"><a href="#HTTP请求的GET和POST方式的区别" class="headerlink" title="HTTP请求的GET和POST方式的区别"></a>HTTP请求的GET和POST方式的区别</h2><blockquote><ul><li>GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</li><li>POST方法通过把请求参数值放在请求体（请求体是什么）中来克服GET方法的限制，因此可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</li></ul></blockquote><h2 id="session与cookie区别"><a href="#session与cookie区别" class="headerlink" title="session与cookie区别"></a>session与cookie区别</h2><blockquote><p>cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。<br>session与cookie区别：（来自知乎:冯特罗<br><a href="https://www.zhihu.com/question/19786827）" target="_blank" rel="noopener">https://www.zhihu.com/question/19786827）</a><br>session在服务器端，cookie在客户端（浏览器）<br>session默认被存在服务器的一个文件里（不是内存）<br>session的运行依赖sessionID，而sessionID是存在cookie中的，也就是说如果禁用cookie，session也会失效（但可通过其他方式实现，如URL中传递session_id）<br>session可以放在文件、数据库或内存中都可以<br>用户验证这种场合一般会用session<br>因此，维护一个会话的核心就是客户端的唯一标识，即sessionID</p></blockquote><h2 id="JDBC流程"><a href="#JDBC流程" class="headerlink" title="JDBC流程"></a>JDBC流程</h2><blockquote><ol><li>加载JDBC程序驱动：<blockquote><p>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），<br>这通过java.lang.Class类的静态方法forName(String className)实现。如：<br>‘’’<br>try{<br>//加载MySql的驱动类<br>Class.forName(“com.mysql.jdbc.Driver”) ;<br>}catch(ClassNotFoundException e){<br>System.out.println(“找不到驱动程序类 ，加载驱动失败！”);<br>e.printStackTrace() ;<br>}<br>‘’’<br>成功加载后，会将Driver类的实例注册到DriverManager类中。</p></blockquote></li><li>提供JDBC连接的URL<br>成功加载后，会将Driver类的实例注册到DriverManager类中。<blockquote><ul><li>连接URL定义了连接数据库时的协议、子协议、数据源标识</li><li>书写形式：协议：子协议：数据源标识<br>协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。数据源标识：标记找到数据库来源的地址与连接端口。<br>例如：<br>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk;useUnicode=true;（MySql的连接URL）<br>表示使用Unicode字符集。如果characterEncoding设置为 gb2312或GBK，本参数必须设置为true 。characterEncoding=gbk：字符编码方式。</li></ul></blockquote></li><li>创建数据库的连接<blockquote><ul><li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。</li><li>使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。<br>如：<br>‘’’<br>String url = “jdbc:mysql://localhost:3306/test” ;<br>String username = “root” ;<br>String password = “root” ;<br>try{<br>Connection con = DriverManager.getConnection(url , username , password ) ;<br>}catch(SQLException se){<br>System.out.println(“数据库连接失败！”);<br>se.printStackTrace() ;<br>}<br>‘’’ </li></ul></blockquote></li><li>创建一个Statement<blockquote><ul><li>要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：<br>1、执行静态SQL语句。通常通过Statement实例实现。<br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。<br>3、执行数据库存储过程。通常通过CallableStatement实例实现。<br>具体的实现方式：<br>Statement stmt = con.createStatement() ;<br>PreparedStatement pstmt = con.prepareStatement(sql) ;<br>CallableStatement cstmt = con.prepareCall(“{CALL demoSp(? , ?)}”) ;</li></ul></blockquote></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="5"><li>执行SQL语句<blockquote><p>Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute<br>1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。<br>2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等<br>3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码：<br>‘’’<br>ResultSet rs = stmt.executeQuery(“SELECT * FROM …”) ;<br>int rows = stmt.executeUpdate(“INSERT INTO …”) ;<br>boolean flag = stmt.execute(String sql) ;<br>‘’’</p></blockquote></li><li>处理结果<blockquote><p>两种情况：<br>1、执行更新返回的是本次操作影响到的记录数。<br>2、执行查询返回的结果是一个ResultSet对象。<br>• ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些 行中数据的访问。<br>• 使用结果集（ResultSet）对象的访问方法获取数据：<br>‘’’<br>while(rs.next()){<br>String name = rs.getString(“name”) ;<br>String pass = rs.getString(1) ; // 此方法比较高效<br>}<br>（列是从左到右编号的，并且从列1开始）<br>‘’’</p></blockquote></li><li>关闭JDBC对象<blockquote><p>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反：<br>1、关闭记录集<br>2、关闭声明<br>3、关闭连接对象<br>‘’’<br>if(rs != null){ // 关闭记录集<br> try{<br>   rs.close() ;<br> }catch(SQLException e){<br>   e.printStackTrace() ;<br> }<br>}<br>if(stmt != null){ // 关闭声明<br> try{<br>   stmt.close() ;<br> }catch(SQLException e){<br>   e.printStackTrace() ;<br> }<br>}<br>if(conn != null){ // 关闭连接对象<br> try{<br>   conn.close() ;<br> }catch(SQLException e){<br>   e.printStackTrace() ;<br> }<br>}<br>‘’’</p></blockquote></li></ol></blockquote><h1 id="MVC设计思想"><a href="#MVC设计思想" class="headerlink" title="MVC设计思想"></a>MVC设计思想</h1><blockquote><p>M:Model 模型<br>V:View 视图<br>C:Controller 控制器<br>模型就是封装业务逻辑和数据的一个一个的模块，控制器就是调用这些模块的（Java中通常是用Servlet来实现，框架的话很多是用Struts2来实现这一层），视图就主要是你看到的，如JSP等。<br>当用户发出请求的时候，控制器根据请求来选择要处理的业务逻辑和要选择的数据，再返回去把结果输出到视图层，这里可能是进行重定向或转发等。</p></blockquote><p>equals与==的区别</p><blockquote><p>值类型（int、char、long、boolean等）都是用==判断相等性。对象引用的话，==判断引用所指的对象是否是同一个。<br>equals是Object的成员函数，有些类会覆盖（override）这个方法，用于判断对象的相等性。<br>例如String类，两个引用所指向的String都是”abc”，但可能出现他们实际对应的对象并不是同一个（和jvm实现方式有关），因此用==判断他们可能不相等，但用equals一定是相等的。</p></blockquote></blockquote><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><blockquote><h2 id="List和Set区别"><a href="#List和Set区别" class="headerlink" title="List和Set区别"></a>List和Set区别</h2><blockquote><p>List，Set都是继承自Collection接口<br>List特点：元素有放入顺序，元素可重复<br>Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉<br>（注意：元素虽然无放入顺序，但元素在set中的位置是由该元素的HashCode决定的，其位置其实是固定的，加入Set的Object必须定义为equals()方法，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）<br>Set和List对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除效率低，因为会引起其他元素位置改变。</p></blockquote><h2 id="List和Map区别"><a href="#List和Map区别" class="headerlink" title="List和Map区别"></a>List和Map区别</h2><blockquote><p>List是对象集合，允许对象重复<br>Map是键值对的集合，不允许key重复</p></blockquote><h2 id="ArrayList与LinkedList区别"><a href="#ArrayList与LinkedList区别" class="headerlink" title="ArrayList与LinkedList区别"></a>ArrayList与LinkedList区别</h2><blockquote><ul><li>ArrayList：<br>优点2：ArrayList是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。<br>缺点：因为地址连续，ArrayList要移动数据，所以插入和删除操作效率比较低</li><li>LinkedList：<br>优点：LinkedList基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinkedList比较占优势。LinkedList适用于要头尾操作或插入指定位置的场景<br>缺点：因为LinkedList要移动指针，所以查询操作性能比较低。</li><li>适用场景分析：<br>当需要对数据进行多次访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</li></ul></blockquote><h2 id="ArrayList与Vector区别"><a href="#ArrayList与Vector区别" class="headerlink" title="ArrayList与Vector区别"></a>ArrayList与Vector区别</h2><blockquote><p>ArrayList和Vector都是用数组实现的，主要有这么三个区别：</p><ol><li>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</li><li>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式不同。</li><li>Vector可以设置增长因子，而ArrayList不可以</li><li>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。<br>适用场景分析：</li><li>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</li><li>如果集合中的元素数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</li></ol></blockquote><h2 id="HashMap与Hashtable区别"><a href="#HashMap与Hashtable区别" class="headerlink" title="HashMap与Hashtable区别"></a>HashMap与Hashtable区别</h2><blockquote><ol><li>hashMap去掉了HashTable的contains方法，但也加上了containsValue()和containsKey()方法。</li><li>hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。</li><li>hashMap允许空键值，而hashTable不允许<br>注意：TreeMap:非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总是处于平衡状态。<br>Treemap:适用于按自然顺序或自定义顺序遍历键（key）。</li></ol></blockquote><h2 id="HashSet与HashMap区别"><a href="#HashSet与HashMap区别" class="headerlink" title="HashSet与HashMap区别"></a>HashSet与HashMap区别</h2><blockquote><p>set是线性结构，set中的值不能重复，hashSet是set的hash实现，hashset中的值不能重复是用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值得唯一来确定，value值则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</p></blockquote><h2 id="HashMap与ConcurrentHashMap区别"><a href="#HashMap与ConcurrentHashMap区别" class="headerlink" title="HashMap与ConcurrentHashMap区别"></a>HashMap与ConcurrentHashMap区别</h2><h2 id="HashMap的工作原理及代码实现"><a href="#HashMap的工作原理及代码实现" class="headerlink" title="HashMap的工作原理及代码实现"></a>HashMap的工作原理及代码实现</h2><p>ConcurrentHashMap的工作原理及代码实现</p></blockquote><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><h2 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h2><h2 id="sleep-、join-、yield-有什么区别"><a href="#sleep-、join-、yield-有什么区别" class="headerlink" title="sleep()、join()、yield()有什么区别"></a>sleep()、join()、yield()有什么区别</h2><h2 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h2><ol><li>wait只能在同步（synchronize）环境中被调用，而sleep不需要。详见Why to wait and notify needs to call from synchronized method</li><li>进入wait状态的线程能够被notify和notifyAll线程唤醒，但是进入sleeping状态的线程不能被notify方法唤醒。</li><li>wait通常有条件地执行，线程会一直处于wait状态，直到某个条件变为真。但是sleep仅仅让你的线程进入睡眠状态。</li><li>wait方法在进入wait状态的时候会释放对象的锁，但是sleep方法不会。</li><li>wait方法是针对一个被同步代码块加锁的对象，而sleep是针对一个线程。更详细的讲解可以参考《Java核心技术卷1》，里面介绍了如何使用wait和notify方法。<br><a href="https://www.jianshu.com/p/25e959037eed" target="_blank" rel="noopener">https://www.jianshu.com/p/25e959037eed</a></li></ol></blockquote><blockquote><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p></blockquote><p>hashMap的扩容原理，初始有13个，要怎么new？(达到了负载因子，直接手动&gt;&gt;1)<br>Integer的常量缓存池的问题(-127~128范围有个cache)<br>ConcurrentHashMap的size()怎么做的（并没有完全加锁，而是先乐观的认为不会有写，通过modCount判断是否更改，这个我当时记不清就用了很多可能、大概、应该这种词，事实证明直接说不清楚会更好）<br>Spring的AOP关于拦截private方法一些问题.(细节忘记了，当时答得也不好)<br>项目中数据字典怎么做的缓存，如何做的通信，有没有用什么模块。（说了自己的做法，用的全局的HashMap，然后他会延伸到高并发的场景，分布式缓存怎么做等等，由于没实际操作经验提前也没准备，并且还没有直接说不会，又是用很多模棱两可的语句答得）<br>讲讲你的论文相关的模型吧（这个其实在简历上根本没写，只是写了数学建模的奖，然后面试官就开始问机器学习的算法，很多都是我没准备的，并且我心想我投的也不是算法岗啊。。。所以说对于简历上的每一条一定要熟悉，做足准备，并且遇到简历上没有都扯到的方面，要想办法转移，不要在这耗着）<br>讲完算法的问题，面试官很尴尬的说了句，你这自己的研究方向你都搞不清楚吗？我当时预感就差不多走远了。。。</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>讲讲项目中怎么实现的充值，锁的机制和事务注解，如何保证了事务的一致性。<br>spring层面做事务和数据库层面做的区别，各自实现方式。<br>聊了事务的传播性和隔离级别，问了mysql的默认隔离级别（可重复读）<br>spring中事务传播性怎么配置（xml方式和注解方式，还有关于savepoint的使用）<br>算法：O(1)删除执行链表结点，做分析（其实是要指出剑指offer中那个直接copy值的方法的缺陷和隐患）<br>算法：二叉树的最长距离（递归的思想）</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>聊项目（这次是针对项目中的加密算法和安全性做了阐述，大概20分钟吧，之前爬虫那个例子已经说了项目亮点要怎么准备了，这里我就不多说了）<br>详细聊了聊spring的IOC和AOP思想<br>关于AOP在spring的应用（比如事务，通知，aspectJ，slf4j的原理,和log4j的对比）<br>关于jdk代理和cglib第三方代理（说出对接口代理和子类继承的区别）<br>用的什么数据库，Mysql。<br>最大的数据量多大，用了索引没有，怎么用的（聊了前缀索引，对于varchar类型的值，又聊了聊char，varchar，text，blob的关系和区别）。<br>为什么索引不能随便用，什么时候用（什么时候失效，什么时候最高效）。<br>如何达到索引开销和性能的平衡，用了一个表去举例。（方法就是，根据情境看经常做的查询是哪些，然后依次是什么查询条件，保证最高效索引的同时，也保证索引不失效，避免无效开销，并且根据show profile和explain功能进行对比分析）<br>数据库用了缓存没有，讲讲redis的理解（用作缓存，队列，也可做存储）。<br>redis是单线程还是多线程的，举个例子（做计数器，rank排行榜）<br>讲讲hbase的原理，CloumnFamily包含哪些，region什么情况做分割，对于版本号这个第四维度的使用方式（一般默认三个版本）等等<br>让我等消息，说经理会联系我。</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>讲了讲项目的设计，包括异常的处理，数据库设计，通信模型的设计。<br>讲讲你理解的JVM吧（从内存划分说到了GC算法、分代思想，CMS和G1 collector，到类加载模型，tomcat的非双亲委派、线程上下文加载器，到JVM调优的策略，gc参数设置策略，如何找死锁，读快照，发现内存泄漏等等吧）</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>线程进程区别<br>说下资源方面的区别，共享，不共享<br>共享的具体哪些资源<br>jvm内存模型<br>堆区的特点<br>数据库左连接右连接，场景<br>给200个200个数的数组，找到最大的200个<br>git 常用的操作，git rebase和git merge区别<br>分布式数据库怎么调用<br>linux常用命令，查看内存，查看磁盘使用率</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>说下jvm吧你知道的，中间会问<br>jvm详细如下<br>如何防止内存泄露，哪些会容易造成<br>jvm调优如何检查内存泄露，如何优化gc参数<br>写sql 查询带日期多次考试成绩表中，每个学生的每门课最高成绩，日期要准确<br>分别用having子句写和用子查询写<br>写代码 旋转数组中查找某一个值</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>hashmap底层结构画一下，手写代码做一个url解析器，用正则方式和hashMap的数据结构。<br>识别2的n次方，写个函数。（最快的是用位操作，大家应该都知道n&amp;(n-1)可以去掉二进制最右的1，那2的n次幂&amp;之后便为0）<br>自己实现http response响应头的结构及解析，用buffer（写个伪代码）<br>resp头中都有什么（主要考察http相关知识）<br>海量数据找到出现次数最多的100个（内存不足的时候可以先做hash分片，最后多路merge，每次操作可以用hashMap计数，也可以自己做hash函数计数）<br>redis底层实现，zset数据结构（问到了SkipList跳表这种结构）<br>jvm内存模型，分代，cpu100% 怎么排查（我以为问Jconsole的使用，其实是想问linux性能监测和调优）<br>用int值表示ip如何做（刚好32位bit一对一映射），写个伪代码做transfer<br>nio模型说一下<br>selector中的wakeup什么含义（这个答得不是很好）<br>select poll epoll （linux内核相关的知识）<br>arraylist.sort怎么实现的（这个可以看看TimSort的思想）<br>怎么看待java跟c++（说下区别和自己的感受）</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>100亿个数找最大1000个（说了分片，用堆，再归并）<br>问你确定吗？（我一想是最大的1000个不是出现次数最多的，其实是可以顺序读取，还是用堆实现）<br>有什么缺点，分布不均匀（说一下堆的复杂度由来）<br>有没有其他思路（用hash散列，计数排序）<br>这个更慢，还有更快的吗（我心想我平时就都是答得堆啊，怎么这次还有更快的？）<br>然后讲了基于partition的划分思想（找到第k个开始partition，在左边就在右面递归，在右面就在左边递归，最后确定partition出最大的k个）<br>这种思想了解了，但最坏情况太差，不稳定，还有更快的吗<br>是不是要用概率统计学，抽样估计？<br>说下思想。。<br>不够精确，还有又精确又稳定的吗？<br>。。。<br>那又给你一个数，你怎么快速告诉我是不是在这100亿个数中？<br>这个我知道有可能是想问Bloom Filter，但是具体到hash函数去几个怎么算，怎么判断误差等细节，我也记不太清了，就说了说思想。</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>一个进程最多申请多大空间（看机器cpu的处理位数看情况）‘<br>怎么保证进程间数据的安全？线程呢？<br>安全方面有没有做过一些研究？<br>登录验证怎么做的，为什么用md5，有没有改进（+salt使md5库难解出），微信用的什么方式你知道吗？你想想应该用什么方式？（这里可能是问SSO单点登录的原理吧，可以讲讲SSO JWT token等技术的原理，这个也是我实习之后了解到的，当时答得一般）<br>那说到通信安全，怎么保证http的安全性，幂等性，回调同一个会话怎么标识不同请求，不同会话怎么区分（这个每个问题都画图叙述了下）<br>TCP 3次握手和timewait讲一下原理<br>讲一下滑动窗口，饱和了怎么处理<br>http安全吗?https说一下？<br>get和post请求<br>linux怎么查看网络状态（vmstat）<br>查看udp的性能，udp端口多少，什么时候用udp？<br>为什么tcp不行？<br>qq里哪些用的tcp哪些用udp？分别针对每种情况说一下为什么？</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>说说你对现有Web开发框架的理解（从各个层入手横向对比优缺点，印象中说了SpringMVC和Struts，mybatis和hibernate及jpa）<br>mybatis和hibernate各自的缓存原理和比较，hibernate的一级二级和查询缓存，还有针对缓存的miss率，置换策略，容量设置和性能的平衡问了自己的理解。<br>要你设计的话，如何实现一个线程池(就讲线程池的原理，从初始线程数，核心线程数，然后到任务队列，满了继续到最大线程数，再满了到饱和策略handler，饱和策略一般有哪几种，基本上要理解ThreadPoolExcuter的构造方法那几个参数)<br>synchronized关键字，实现原理（和Lock对比着说，说到各自的优缺点，synchronized从最初性能差到jdk高版本后的锁膨胀机制，大大提高性能，再说底层实现，Lock的乐观锁机制，通过AQS队列同步器，调用了unsafe的CAS操作，CAS函数的参数及意义；同时可以说说synchronized底层原理，jvm层的moniter监视器，对于方法级和代码块级，互斥原理的不同，+1-1可重入的原理等）<br>算法：手写一个ArrayList类，实现add，remove，等基本的方法（主要考扩容的原理和实现，重点写出扩容机制以及扩容时的copy过程）<br>然后让对这个ArrayList进行改进，使之可以应对并发的场景<br>算法：手写字符串的正则匹配，实现*和.的功能，用的递归（写了一半他说时间差不多了，思想大概了解了）。</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>NIO的原理，jdk中有哪些工具和类去实现，如何实现（selector和channel的用法）,真的好用吗？还可以用什么？（面试官应该是想问netty，因为没有实际用过，只能给他讲了netty的原理）<br>那来说说AIO吧，和NIO什么区别（对异步的理解）,AIO在工程中如何实现的？（大概说了下ajax的回调函数），又问回调函数具体是怎么实现的（传递函数指针）。<br>然后借着异步IO想问消息队列，讲了一下几种模型和原理。（面试中没有用过没关系，只要你懂原理还是可以跟面试官讲，起码可以证明你是爱学习的）<br>项目中非技术上的困难（和甲方沟通需求，没有规范化的项目设计，需求变更太频繁等），问了我解决的方法还有以后希望怎么改进。（变相问互联网公司里面各个team以及需求方是如何合作和分工的）<br>讲讲Spring中怎么对初始化的bean做其他操作。（这里有三种方式，@PostConstruct注解方式，init-method的XML配置方式，InitializingBean接口方式）<br>三种实现上有什么区别（还好看过点源码，其实前两种是一个意思，都是通过反射的方式用aop思想实现，可以消除对spring的依赖；接口方式是直接调用afterPropertiesSet方法，效率更高点。spring加载bean时先判断接口方式，再执行配置注解方式）<br>算法题，一个先减后增的数组，查找目标值。（这里并不是查找最值，也不是剑指offer上的旋转数组，但是思想上也可以用二分的方式）<br>算法题，两个大数求和，要按高到低位的输入，实时输出结果的对应位，空间O，时间O(n)，不借助工具类。（要考虑实时的进位标识，以及多个9之后的连续进位标识）</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>算法：int范围的随机数的阶乘编码实现。<br>（这个题如果直接按最简单的算法题肯定是不行的）<br>1.首先考虑要用字符串做运算(因为中间数太大了，只有String能保存，当然你可以借助BigInteger或BigDecimal类去辅助实现)。<br>2.阶乘直接计算代价太大，循环太多，考虑设计中间缓存。（正常算复杂度太高，本身就是阶乘级的，所以正常想到用时间换空间）<br>3.只用空间换时间的话缓存也不能覆盖全部，如果把所有的中间值保存，空间是eb级别，不现实。（这里就要达到一个空间和时间复杂度的平衡点）<br>4.存部分中间值用部分空间换取时间，达到空间复杂度和时间复杂度的最优平衡。（开始说的二分做分割存储之后改为等间隔做分隔存储，间隔选取多长为好？我觉得要首先确定空间复杂度的接受极限，然后尽可能减小时间复杂度，因为空间复杂度是可以有预估值的，而时间复杂度当然我们是希望约小越好的）</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>解释下iaas.paas.saas和之间的关系，外呼接口和服务怎么调用的。<br>数据库主从备和读写分离原理，ibatis怎么配置。（这个只讲了数据库层面的原理，比如监听线程，主机和从机的同步方式等，但是具体代码层面的配置，由于没亲自做过，就说不太知道。）<br>算法，股票最长增长区间，优化<br>算法，最长递增子序列，一个dp数组一个max数组，最优情况</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>ava基础，从头到尾问了个遍，都是大家准备的，但是也挺深的，包括：<br>hashMap，红黑树处理冲突，jdk7和jdk8有什么区别<br>JUC相关的集合，ConcurrentHashMap jdk7和jdk8的区别，Collections.sort函数jdk7 和 jdk8 分别怎么实现的。（总感觉这个面试官在某段时间肯定纠结过两个版本）<br>CopyOnWriteList底层是什么，适用的情况，vector的特点，实现的是List接口吗。<br>并发的问题，线程间通信三种方式<br>锁的膨胀过程，Synchronized和Lock的区别，底层的monitor实现和unsafe类的CAS函数，参数表示什么，寄存器cpu如何做）<br>volatile cpu和寄存器层面是怎么实现的。<br>线程池构造函数参数，各种类型的预设池各自的特点，ForkJoinPool是怎么实现的，多线程等等问了一个遍。<br>为什么匿名内部类的变量必须用final修饰，编译器为什么要这么做，否则会出现什么问题<br>数据库：<br>索引的分类。<br>主键索引和普通索引的区别，组合索引怎么用会失效。<br>索引的前缀匹配的原理，从B树的结构上具体分析一下。<br>聚集索引在底层怎么实现的，数据和关键字是怎么存的。<br>组合索引和唯一性索引在底层实现上的区别（这个是整个一面感觉答得不好的一个问题，不太明白面试官想问啥）<br>sql的优化策略，慢查询日志怎么操作，参数含义。<br>explain 每个列代表什么含义（关于优化级别 ref 和 all，什么时候应该用到index却没用到，关于extra列出现了usetempory 和 filesort分别的原因和如何着手优化等）<br>show profile 怎么使用。</p><p>作者：<em>XiaoTeng</em><br>链接：<a href="https://www.nowcoder.com/discuss/29890" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/29890</a><br>来源：牛客网</p><p>一个url到页面全过程（让我能说多详细说多详细，最好从OSI七层的每一层去扩展）<br>http的请求头格式（这个真的记不太清了，只说了几个有印象的标志位）<br>getpost区别，post可不可以用url的方式传参。<br>说到了url有最大长度，就问长度有限制是get的原因还是url的原因，为什么长度会有限制，是http数据包的头的字段原因还是内容字段的原因，详细说明。（在他一步步追问下答了个差不多）<br>关于幂等性的详细介绍。<br>幂等性是http层面的问题吗，还是服务器要处理和解决的内容。（就是看你对幂等性的定性是怎么理解的）<br>后台服务器对于一个请求是如何做负载均衡的，有哪些策略，会出现什么样的问题，怎么解决。（说了一致性hash算法，分布式hash的特性,具体的应用场景，又非要问我知不知道这个最早在哪个公司使用的…我说这个真不知道。好像是amazon?）<br>说说http的缺点，无状态，明文传输。<br>那https是怎么做的，如何实现的？ca认证机构。<br>然后问我https ssl tcp三者关系，其中哪些用到了对称加密，哪些用到了非对称加密，非对称加密密钥是如何实现的。（还好我项目中涉及到了一些加密）<br>关于加密的私钥和公钥各自如何分配（客户端拿公钥，服务器拿私钥）<br>那客户端是如何认证服务器的真实身份，详细说明一下过程，包括公钥如何申请，哪一层加密哪一层解密。<br>java的优先级队列，如果让你设计一个数据结构实现优先级队列如何做？<br>用TreeMap复杂度太高，有没有更好的方法。<br>hash方法，但是队列不是定长的，如果改变了大小要rehash代价太大，还有什么方法？<br>用堆实现，那每次get put复杂度是多少（lgN）<br>（思想就是并不一定要按优先级排队列的所有对象，复杂度太高，但每次保证能取最大的就行，剩下的顺序不用保证，用堆调整最为合适）<br>在线编程题：敲一个字串匹配问题，写了常规代码。问kmp的代码思想，最后问了下正则中用的改进后的BM算法。（还有个比较新奇的Sunday算法，有兴趣的同学也可以看一下）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文学习（A Smart Meeting Management System With Video Based Seat Detection内容翻译）</title>
    <link href="undefined2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <url>2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote><p>如今智能会议管理受到人们的广泛关注。现有的大多数智能系统只关注小型会议室中的谈话记录，而本文介绍了一种大礼堂智能会议管理系统。系统中嵌入了级联空座检测算法，以获取每个座位的状态。根据遮挡的程度逐级标示空位情况。结合预先输入的与会者信息，系统可以在会议期间为人们提供就座情况和相应的与会者信息。实验结果表明，座椅状态检测精度可达99.8%。</p></blockquote><h1 id="类别和主题描述符"><a href="#类别和主题描述符" class="headerlink" title="类别和主题描述符"></a>类别和主题描述符</h1><blockquote><p>H.4[图像处理与计算机视觉]:杂项</p></blockquote><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><blockquote><p>智能会议，视频分析，座位检测</p></blockquote><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><blockquote><p>会议是以交流和交换信息为目的的最常见的活动之一。因而会议的智能化管理对于提高会议管理的效率，营造安全的会议环境具有非常重大的意义。会议智能管理系统旨在了解会议室中发生了什么、正在发生什么以及将要发生什么。因此，基于物体检测跟踪、行为识别等的视频分析在智能会议管理中扮演着非常重要的角色。</p><p>到目前为止，已经有许多智能会议相关的概念, [1, 2, 3, 4]. 其中有许多都借助视频分析来理解其情境中的内容。检测和跟踪的方法是用来分析与会者的行为[5,6]，以了解在会议室里发生了什么。然而，在一个大礼堂里，人们总是在整个会议过程中坐在自己的座位上。 很少有互动发生。在室内环境中，遮挡和阴影是检测和跟踪的两个主要问题。 为了解决这个问题，之前的一些作品使用了对阴影和照明等变化不敏感的3D信息[7,8]。此外，基于3D的方法需要强大的硬件支持，尤其是在参会者众多的情况下，使得这些方法很难满足实时性的要求。除了3D方法，Dai等人[9]利用运动、颜色、梯度、原始灰度特征作为视觉线索，形成一个增强级联[10]以供人物检测。他们认为运动是人类存在的重要线索，这使得运动对光照变化和其他干扰非常敏感。在[3]中，人脸检测直接参与其中。然而，由于人脸识别在这一过程中是必要的，因此人脸的角度至关重要。虽然这个问题可以通过建立包含一定角度的训练人脸数据库来解决，但是在会议中仍然需要估计人脸的朝向。</p><p>然而，这些系统更多的关注的是人们在会议过程中的互动，然而这里仍存在很多局限。例如，[1]要求会议室较小，系统可以通过高质量的图像捕捉到参与者行为的细节; [2]参加者人数应足够少，以使系统免受严重的干扰和阻塞;[3]到场人员流动性低是保证系统有效性的必要条件; [4]这些系统强调对个人的分析，应该安装大量的摄像头，以确保每个人都有一个良好的视野在全领域。因此，它们只适用于人数不超过10人的小型会议室。</p><p>在如图1所示的可以容纳数千人的大礼堂中，记录参与者的状态比记录他们的互动更重要。在如图1所示的可以容纳数千人的大礼堂中，记录参与者的状态比记录他们的互动更重要。本文关注的是大礼堂的整体情况，而不是个人的行为。礼堂的情况可以通过会议期间的人的存在来反映。考虑到座位与参会者之间的一致性，该问题可视为座位检测问题。了解参会者在座位上的状态是一种直接控制和预测会议进展的方法。这将有助于人们在会议管理方面采取适当的行动。</p><p>在大礼堂中，座椅检测任务存在许多具体问题。第一个问题是在礼堂面积大，人数多的情况下，如何在图像分辨率和摄像机数量之间保持良好的平衡。其次，座椅检测容易产生严重的噪声。座椅的特点应该是对光照变化、人影和光点有较强的鲁棒性。第三，外部干扰对座椅检测结果造成很大的干扰。针对上述问题，本文提出了一些解决方案。视频捕捉设备是PTZ摄像机，可以在多个预设之间切换。针对严重的噪声问题，提出了一种三步走检测算法。最后，有一个校准过程来处理所有座椅信息的统计，这个过程可以纠正由于座椅情况临时变化而导致的错误结果。</p><p>本文主要为构建智能会议提供两种支持:1)在大型礼堂中使用PTZ摄像机采集图像;2)提出了一种处理遮挡的座椅检测的三步检测方法。论文的提纲如下。第2节首先对座椅检测算法进行了详细介绍。第3节给出了在实际礼堂中的实验结果和应用，验证了所提出的座椅检测算法的有效性。最后对工作进行了总结，并对今后的工作进行了展望。</p></blockquote><hr><h1 id="2-座位检测"><a href="#2-座位检测" class="headerlink" title="2 座位检测"></a>2 座位检测</h1><blockquote><p>本节将详细介绍座椅检测算法。座位检测的任务可以描述为座位是否有人坐的问题。然而，在会议期间，一些座位会被严重的噪音所堵塞，比如包或衣服。在这种情况下，很难发现他们是空座位。针对这一问题，提出了一种三步检测方法。它是建立在一个推进级联的基础上的。其基本思想是，座椅的外观根据遮挡的级别和位置变化很大。事实上，所有的空座在颜色、形状和质地上都表现出高度的一致性。虽然空座位易发生遮挡，但遮挡往往发生在座位侧面，而遮挡的空座位顶部仍保持原有特征。一旦一个座位被与会者占据，这个座位几乎失去了图像中所有的原始外观。因此，我们将座椅分为三种类型:完全空的、遮挡空的和非空的，如图2所示。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/2.png" srcset="/img/loading.gif" alt></p></blockquote><blockquote><p>这三个步骤分别是粗检索过程、细检索过程和结果校准。图3所示为提出的回收空座位的升压级联结构。由于外观一致性高，首先对完全空的座椅进行检索，加快了整个过程的速度，这是一个粗糙的检索过程。在此基础上，对闭塞的空座和非空座进行了具有良好特性的分析，以保证系统的精度。这是一个很好的检索过程。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/3.png" srcset="/img/loading.gif" alt></p><h2 id="2-1-粗检索过程"><a href="#2-1-粗检索过程" class="headerlink" title="2.1 粗检索过程"></a>2.1 粗检索过程</h2><blockquote><p>粗检索过程的目的是区分完全空的座位、封闭的空的座位和非空的座位。考虑到所有的空位在外观上具有高度的一致性，当一个空位被占据时，其外观变化很大。因此，背景和前景之间的减法迅速增加，可以用来获得座椅的状态。首先建立背景模型。为简单起见，礼堂中没有人时拍摄的视频可以用作背景模型。前景区域是直接获得的实时视频。然后使用背景减法。为了对光照变化具有一定的鲁棒性，在HSV颜色空间和梯度图中实现了背景减法。每个座椅的特点可以描述为:</p><p>$$ f^hsv_i = ∥f^hsv_bg − f^hsv_fg ∥_1 $$ </p><p>$ f^grd_i = ∥f^grd_bg − f^grd_fg ∥_1 $  (1)</p><p>最终座位状态 $ S_i $ 通过下式获得:</p><p>$$ S_i = \begin{cases} 0, &amp; \text {if $f^hsv_i + f^grd_i$ &gt; θ} \ 1, &amp; \text{else} \end{cases} $$   (2)</p><p>这里$θ$是状态$ S_i $的阈值</p></blockquote><h2 id="2-2-细检索过程"><a href="#2-2-细检索过程" class="headerlink" title="2.2 细检索过程"></a>2.2 细检索过程</h2><blockquote><p>精细检索过程的目的是区分被遮挡的空座位和非空座位。这是通过对座椅的精细纹理和轮廓分析来实现的。</p><p>HOG特征在很多应用中都被证明是有效的，比如对象检测。考虑到座位被人遮挡和占据时遮挡位置的不同，提出了简化HOG特征(S-HOG)[11]。提取S-HOG的过程如图4所示。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/4.png" srcset="/img/loading.gif" alt></p></blockquote></blockquote><blockquote><blockquote><p>首先计算每个座块的梯度图，然后将其划分为8*8像素的单元格。在提取HOG特征的过程中，计算每个单元的梯度方向直方图。座块的每个单元表示座位的不同部分。当座椅被人或衣服遮挡时，座椅外观的轮廓会发生变化。根据人体姿势的一致性，座椅的一些单元容易被遮挡，而另一些单元则不会。因此，给每个单元分配一个权重来表示遮挡对座椅状态识别的影响。通过提取所有单元的HOG特征，对遮挡的空座和非空座进行分类。不同的单元分类器的精度不同，反映的是遮挡不同位置对结果的影响不同，这也被成为单元的权重。因此S-HOG特征可以被描述为：</p><p>$ f_S-HOG = {w_1f_1, w_2f_2, · · · , w_{M∗N} f_{M∗N} } $  (3)</p><p>其中$M$、$N$为$x$、$y$方向的单元数，$f_i$为单元的HOG特征，$w_i$为细胞平均权重。</p><p>默认情况下，我们使用线性SVM来训练分类器进行检测。</p></blockquote><h2 id="2-3-按时间结果校准"><a href="#2-3-按时间结果校准" class="headerlink" title="2.3 按时间结果校准"></a>2.3 按时间结果校准</h2><blockquote><p>通过从粗到细的空座位检索过程，礼堂中的每个座位都分配了一个标签来表示其状态。但是，由于外部干扰，可能会有一些误差。这些错误是由一些暂时的干扰造成的。例如，人们走过空的座位或经过空的座位。因此，结果校准的目的是纠正座椅的临时错误判断。本文采用一段时间内检测结果的中值滤波进行校正。</p></blockquote></blockquote><hr><h1 id="3-实验结果与应用"><a href="#3-实验结果与应用" class="headerlink" title="3 实验结果与应用"></a>3 实验结果与应用</h1><blockquote><h2 id="3-1-PTZ摄像头设置"><a href="#3-1-PTZ摄像头设置" class="headerlink" title="3.1 PTZ摄像头设置"></a>3.1 PTZ摄像头设置</h2><blockquote><p>考虑到礼堂可容纳数千人，场地面积大，摄像机设置应保证礼堂内所有座位都被遮挡住，所拍摄的图像分辨率高，而使用的摄像机越少越好。工作的(12、13、14),他们采用全方位摄像机可以覆盖360◦实现高覆盖率。这个方案的问题是，随着座椅和相机之间距离的增加，遮挡会变得更加严重。这给座椅检测工作带来了困难。</p><p>一般来说，避免遮挡的最佳拍摄角度是安装在座椅上方。只要相机与座椅之间的距离足够长，座椅的变形和遮挡问题就可以忽略。我们将礼堂分成几个区域，然后为每个PTZ摄像机设置5-6个预设，如图1所示。每个预设值负责一个区域。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/1.png" srcset="/img/loading.gif" alt></p></blockquote></blockquote><blockquote><h2 id="3-2-座椅检测结果"><a href="#3-2-座椅检测结果" class="headerlink" title="3.2 座椅检测结果"></a>3.2 座椅检测结果</h2><blockquote><p>座位检测算法适用于可容纳上千人的大型礼堂。从两个会议区域提取的座位块作为训练集，其中包含1982个空座位块和2946个非空座位块。将另一次约1小时的会议视频作为测试集，从该数据集中采集77幅经典图像。对礼堂内随机区域的地面真值进行了标定，验证了算法的有效性。区域覆盖64个座位，每个座位块平均为80 * 100像素。</p><p>本文采用空座位召回率来评价所提出的检测算法。考虑到粗检索过程和细检索过程针对不同类型的空座位进行检索，分别得到了完全空座位和遮挡空座位的查全率。在77*64=4928个座块中，有1259个为完全空座，735个为封闭空座，2934个为非空座。座椅检测结果如表1所示。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/b1.png" srcset="/img/loading.gif" alt></p><p>粗检索过程的目的是检索完全空的座位。在此过程中，在HSV颜色空间中实现背景减法，以保证特征对光照变化具有鲁棒性。对于与座椅颜色相同的一些人，使用梯度图的背景减法来捕捉座椅块轮廓的变化。因此，粗检索过程可以回忆起几乎所有完全空的位置，如表1所示。对于剩余座椅，采用精细回收工艺。召回被封闭的空座位的结果也令人满意。针对这两种方法误差较小的情况，采用标定模块对扰动进行滤波。实验结果表明，在标定前，阀座检测精度达到99.73%，标定后，阀座检测精度达到99.87%。系统的最终结果如图5 (a)和(b)所示。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/5.png" srcset="/img/loading.gif" alt></p></blockquote><h2 id="3-3-座椅检测的应用"><a href="#3-3-座椅检测的应用" class="headerlink" title="3.3 座椅检测的应用"></a>3.3 座椅检测的应用</h2><blockquote><p>构建了一种基于座位检测的智能会议系统。该系统结合参会人员信息的提前输入，为参会人员提供会议期间大礼堂的整体情况。该系统在信息自动显示和快速查询两方面满足了人们对智能管理的要求。由于礼堂的管理涉及到所有参会者的管理，所以既要考虑到礼堂的整体情况，又要考虑到每个座位的细节。</p><h3 id="3-3-1-大礼堂的整体情况"><a href="#3-3-1-大礼堂的整体情况" class="headerlink" title="3.3.1 大礼堂的整体情况"></a>3.3.1 大礼堂的整体情况</h3><blockquote><p>为了覆盖大礼堂，系统使用多个PTZ摄像机对大礼堂内的每个区域进行扫描。然后我们把各个区域组合在一起，得到礼堂的整体情况。如图6所示，电子分布图作为全局描述形成。在电子分布图中，礼堂的每个座位都被描述成一个长方形，座位的状态用不同的颜色表示。一旦座位被新入座者或缺席者占据，相应座位的颜色就会发生变化，从而直接反映出礼堂的整体情况。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/6.png" srcset="/img/loading.gif" alt></p><p>随着时间的推移，电子分布图的历史数据被保存下来。任何时候的电子分布图都可以查询。同时，为了方便查找全局的变化，形成了一段时间内的统计量。查询特定的座位或与会者可以快速定位到礼堂的准确位置，如图7所示。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/7.png" srcset="/img/loading.gif" alt></p></blockquote><h3 id="3-3-2-大礼堂的局部情况"><a href="#3-3-2-大礼堂的局部情况" class="headerlink" title="3.3.2 大礼堂的局部情况"></a>3.3.2 大礼堂的局部情况</h3><blockquote><p>局部情况展示是查看礼堂区域的详细信息，如图8所示。视图中的每个参与者的信息都可以被获取，包括姓名、公司、出席时间等。每个与会者和每个座位的当前历史保存为表单<br>统计数据。</p><p><img src="/2019/02/19/A-Smart-Meeting-Management-System-With-Video-Based-Seat-Detection论文翻译/8.png" srcset="/img/loading.gif" alt></p></blockquote></blockquote></blockquote><hr><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><blockquote><p>本文提出了一种以座位状态为核心的实时智能会议管理系统，避免了其他行为分析系统的不足。采用PTZ摄像机代替传统摄像机，可以以更低的成本覆盖整个礼堂。在检测中，通过一种由粗到细的空座椅检索方法，可以准确地获取各个座椅的状态，不受遮挡和严重噪声的干扰。结合座位和参会者的不同，系统可以为用户提供整个会议期间的每个座位和每个参会者的情况。在实际会议上的实验结果验证了所提出的座椅检测系统的有效性。</p></blockquote><hr><h1 id="5-致谢"><a href="#5-致谢" class="headerlink" title="5 致谢"></a>5 致谢</h1><blockquote><p>本课题由国家基础研究计划(批准号:2012cb316302)、国家重点技术研发计划(批准号:2012bah07b01)、国家自然科学基金(61105009)资助。</p></blockquote><hr><h1 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6 参考文献"></a>6 参考文献</h1><blockquote><p>[1] Z. Yu and Y. Nakamura, “Smart meeting systems: A survey of state-of-the-art and open issues,” ACM Computing Surveys (CSUR), vol. 42, no. 2, p. 8, 2010.</p><p>[2] M. Bett, R. Gross, H. Yu, X. Zhu, Y. Pan, J. Yang, and A. Waibel, “Multimodal meeting tracker,” in Proceedings of RIAO, 2000.</p><p>[3] I. Mikic, K. Huang, and M. Trivedi, “Activity monitoring and summarization for an intelligent meeting room,” in Human Motion, 2000. Proceedings. Workshop on, pp. 107–112, IEEE, 2000.</p><p>[4] D.-S. Lee, B. Erol, J. Graham, J. J. Hull, and N. Murata, “Portable meeting recorder,” in Proceedings of the tenth ACM international conference on Multimedia, pp. 493–502, ACM, 2002.</p><p>[5] P. Dai, L. Tao, and G. Xu, “Audio-visual fused online context analysis toward smart meeting room,” in Ubiquitous Intelligence and Computing, pp. 868–877, Springer, 2007.</p><p>[6] K. S. Huang and M. M. Trivedi, “Video arrays for real-time tracking of person, head, and face in an intelligent room,” Machine vision and applications, vol. 14, no. 2, pp. 103–111, 2003.</p><p>[7] T. Svoboda, H. Hug, and L. Van Gool, “Viroom , a llow cost synchronized multicamera system and its self-calibration,” in Pattern Recognition, pp. 515–522, Springer, 2002.</p><p>[8] J. Krumm, S. Harris, B. Meyers, B. Brumitt, M. Hale, and S. Shafer, “Multi-camera multi-person tracking for easyliving,” in Visual Surveillance, 2000. Proceedings. Third IEEE International Workshop on, pp. 3–10, IEEE, 2000.</p><p>[9] P. Dai, L. Tao, and G. Xu, “Dynamic context driven human detection and tracking in meeting scenarios,” in Proc. 2nd Intl. Conf. on Computer Vision Theory and Applications, 2007.</p><p>[10] P. Viola and M. Jones, “Rapid object detection usinga boosted cascade of simple features,” in Computer Vision and Pattern Recognition, 2001. CVPR 2001. Proceedings of the 2001 IEEE Computer Society Conference on, vol. 1, pp. I–511, IEEE, 2001.</p><p>[11] H. Liang, J. Wu, and K. Huang, “People in seats counting via seat detection for meeting surveillance,” in Pattern Recognition, pp. 202–210, Springer, 2012.</p><p>[12] Z. Yu, M. Ozeki, Y. Fujii, and Y. Nakamura, “Towards smart meeting: enabling technologies and a real-world application,” in Proceedings of the 9th international conference on Multimodal interfaces, pp. 86–93, ACM, 2007.</p><p>[13] J. S. Garofolo, C. D. Laprun, M. Michel, V. M.Stanford, and E. Tabassi, “The nist meeting room pilot corpus,” in Proc. of Language Resource and Evaluation Conference, 2004.</p><p>[14] C. Busso, S. Hernanz, C.-W. Chu, S.-i. Kwon, S. Lee, P. G. Georgiou, I. Cohen, and S. Narayanan, “Smart room: participant and speaker localization and identification,” in Acoustics, Speech, and Signal Processing, 2005. Proceedings.(ICASSP’05). IEEE International Conference on, vol. 2, pp. ii–1117, IEEE, 2005.</p></blockquote><hr><hr><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><blockquote><p><a href="http://xueshu.baidu.com/usercenter/paper/show?paperid=37267b08f69aa2640aab781b2d4c1178&amp;site=xueshu_se" target="_blank" rel="noopener">http://xueshu.baidu.com/usercenter/paper/show?paperid=37267b08f69aa2640aab781b2d4c1178&amp;site=xueshu_se</a></p></blockquote><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><blockquote><p>座位检测 seat-detection<br>实时性 real-time</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>座位检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专业学习情况 ---kind of 自我剖析</title>
    <link href="undefined2019/02/18/selftesting/"/>
    <url>2019/02/18/selftesting/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在准备实习面试，找工作看到职位要求的时候，感觉自己在专业方面学了很多但专通的很少，所以想把学习过的东西整理一下，便于自己对自己的专业能力以及目标职位有一个清晰的认识。</p></blockquote><blockquote><h1 id="0-本科课程学习的知识"><a href="#0-本科课程学习的知识" class="headerlink" title="0 本科课程学习的知识"></a>0 本科课程学习的知识</h1><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a><strong>C语言</strong></h3><p>大一基本使用的都是C语言或是伪C++，并应用C语言做课程设计，主要是对数据结构的应用，内容是路线查找，最短路径等，如果需要使用C语言做项目的话应该是比较容易上手的，可能有难度的是算法的设计使用吧</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>考研初试准备中复习了重要的数据结构、算法，但是感觉如果面试相关内容如各种排序算法的话，仍然需要复习一下</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>Java是大学期间接触最多的一门语言，但是几乎没有用Java做过较大的项目,除课程设计之外，只有在毕设学习微信公众号开发时有简单用到。由于没有系统的较大项目的应用，因此对Java线程等的内容仍然比较模糊（由于毕设需要用到，因此会继续系统的学习线程的使用方法）</p><h3 id="JSP网站开发"><a href="#JSP网站开发" class="headerlink" title="JSP网站开发"></a><strong>JSP网站开发</strong></h3><p>MVC分层、SSH、SSM等是选择企业方向后主要学习的内容，但是想要找相关工作的话仍然需要进一步熟悉模型、框架等的原理</p><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a><strong>前端开发</strong></h3><p>主要为css、js、dom、div、jquery、bootstrap等。自我感觉基本内容掌握较为扎实，但是一些标签页等内容学习的时候感觉很熟练，但现在仍然需要复习才能使用。最近有些犹豫要不要发展前端，由于之前的想法一直都是后台开发，所以没有对前端做更深入的学习。</p><h3 id="计算机网络原理"><a href="#计算机网络原理" class="headerlink" title="计算机网络原理"></a><strong>计算机网络原理</strong></h3><p>在各种招聘信息中，很多都需要熟练掌握internet常见协议，熟悉Http协议、TCP/IP等协议。课程学习的时候有认真学习，但是感觉忘了好多，三次握手等内容。是非常重要的需要复习的内容。</p><h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a><strong>计算机组成原理</strong></h3><p>同样作为考研初试准备科目，主要为指令、控制器等内容。</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><strong>操作系统</strong></h3><p>操统是考研复试要准备科目，年前有简单复习（主要为过目录），学习的时候蛮清楚的，过了大约一年的时间感觉忘了好多。</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a><strong>数据库设计</strong></h3><h3 id="软件工程概论"><a href="#软件工程概论" class="headerlink" title="软件工程概论"></a><strong>软件工程概论</strong></h3><h3 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a><strong>离散数学</strong></h3><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a><strong>编译原理</strong></h3><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h3><h3 id="Linux基础使用"><a href="#Linux基础使用" class="headerlink" title="Linux基础使用"></a><strong>Linux基础使用</strong></h3><h3 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a><strong>UI设计</strong></h3><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a><strong>软件测试</strong></h3><h3 id="python程序设计"><a href="#python程序设计" class="headerlink" title="python程序设计"></a><strong>python程序设计</strong></h3><h3 id="大数据技术与应用"><a href="#大数据技术与应用" class="headerlink" title="大数据技术与应用"></a><strong>大数据技术与应用</strong></h3><h3 id="…"><a href="#…" class="headerlink" title="…"></a><strong>…</strong></h3></blockquote><blockquote><h1 id="1-项目中学到的知识"><a href="#1-项目中学到的知识" class="headerlink" title="1 项目中学到的知识"></a>1 项目中学到的知识</h1><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h3><p>由于自己在项目中担任语句分类模块，所以主要使用Python，且后续学校有开设python课程，以及小牛学堂的python程序设计比赛，所以对python很熟悉，人工智能是其主要应用方面，除此之外，与其他语言的使用没有太大差别，主要为算法的设计</p><h3 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a><strong>机器学习算法</strong></h3><p>在项目实现过程中，清楚的了解到文本分类的整体流程（分词-&gt; 特征提取-&gt; 分类器分类（分类器训练 + 分类器测试 + 应用））<br>了解各种分词并使用结巴分词<br>简单了解主要分类算法：k近邻、K-means、SVM、朴素贝叶斯等</p></blockquote><blockquote><h1 id="2-毕业设计正在学习的知识"><a href="#2-毕业设计正在学习的知识" class="headerlink" title="2 毕业设计正在学习的知识"></a>2 毕业设计正在学习的知识</h1><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a><strong>计算机视觉</strong></h3><p>据了解，图像识别领域神经网络可以取得非常出色的成果，因此想用卷积神经网络来实现，应用OpenCV(python)，仍在起步阶段，还有很多东西要学，在短时间内。</p><h3 id="微信公众号开发"><a href="#微信公众号开发" class="headerlink" title="微信公众号开发"></a><strong>微信公众号开发</strong></h3><p>应用Java开发，基本功能可实现，但由于应用会用到多线程处理以及数据库存储，因此，还有一部分内容需要学习。</p></blockquote><blockquote><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>总觉得自己学了很多内容，但面对招聘信息还是觉得自己什么都不会，甚至一些词语都没有见过。</p><p>tip:明确自己的方向，认真踏实的准备面试，保持不断学习的心态，步履不停……</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Orange-first-writing</title>
    <link href="undefined2019/02/17/first-writing/"/>
    <url>2019/02/17/first-writing/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第一次动手搭建自己的博客，用了不到一天的时间（据说五分钟就可以┐（~ー~;）┌）<br>之前一直都是在CSDN记录自己的项目问题、专业学习，看到同学大佬用Hexo搭建的文章博客很精致，所以也想搭建一个属于自己的博客空间，很期待在这里记录自己的一些随笔心得和专业方面的成长……<br>Nice to meet you.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>